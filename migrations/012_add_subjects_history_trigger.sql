BEGIN;

-- ============================================================================
-- Migration: 012_add_subjects_history_trigger.sql
-- Purpose: Create automated audit trail system for SUBJECTS table
-- Description: Tracks all UPDATE and DELETE operations with full history
-- ============================================================================

-- ============================================================================
-- Step 1: Create SUBJECTS_HISTORY Table
-- ============================================================================

-- Create the history table if it doesn't exist
CREATE TABLE IF NOT EXISTS "SUBJECTS_HISTORY" (
    -- Audit metadata columns
    "HISTORY_ID" BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "OPERATION_TYPE" VARCHAR(10) NOT NULL,
    "MODIFIED_AT" TIMESTAMPTZ(6) NOT NULL DEFAULT NOW(),
    "MODIFIED_BY" BIGINT,
    
    -- Original SUBJECTS table columns (snapshot of data before change)
    "ID" BIGINT NOT NULL,
    "TYPE_STRUCTURE" VARCHAR(250),
    "CODE_UKNF" VARCHAR(250),
    "NAME_STRUCTURE" VARCHAR(500),
    "LEI" VARCHAR(20),
    "NIP" VARCHAR(10),
    "KRS" VARCHAR(10),
    "STREET" VARCHAR(250),
    "NR_STRET" VARCHAR(250),
    "NR_HOUSE" VARCHAR(250),
    "POST_CODE" VARCHAR(250),
    "TOWN" VARCHAR(250),
    "PHONE" VARCHAR(250),
    "EMAIL" VARCHAR(500),
    "UKNF_ID" VARCHAR(100),
    "STATUS_S" VARCHAR(250),
    "KATEGORY_S" VARCHAR(500),
    "SELEKTOR_S" VARCHAR(500),
    "SUBSELEKTOR_S" VARCHAR(500),
    "TRANS_S" BOOLEAN,
    "DATE_CREATE" TIMESTAMPTZ(6),
    "DATE_ACTRUALIZATION" TIMESTAMPTZ(6),
    "VALIDATED" BOOLEAN,
    
    -- Constraints
    CONSTRAINT "SUBJECTS_HISTORY_OPERATION_CHECK" 
        CHECK ("OPERATION_TYPE" IN ('UPDATE', 'DELETE'))
);

-- Add indexes for efficient querying
CREATE INDEX IF NOT EXISTS "IDX_SUBJECTS_HISTORY_SUBJECT_ID" 
    ON "SUBJECTS_HISTORY"("ID");

CREATE INDEX IF NOT EXISTS "IDX_SUBJECTS_HISTORY_MODIFIED_AT" 
    ON "SUBJECTS_HISTORY"("MODIFIED_AT" DESC);

CREATE INDEX IF NOT EXISTS "IDX_SUBJECTS_HISTORY_OPERATION_TYPE" 
    ON "SUBJECTS_HISTORY"("OPERATION_TYPE");

CREATE INDEX IF NOT EXISTS "IDX_SUBJECTS_HISTORY_MODIFIED_BY" 
    ON "SUBJECTS_HISTORY"("MODIFIED_BY") 
    WHERE "MODIFIED_BY" IS NOT NULL;

-- Add foreign key to USERS table (nullable for system operations)
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_constraint 
        WHERE conname = 'SUBJECTS_HISTORY_MODIFIED_BY_FK'
    ) THEN
        ALTER TABLE "SUBJECTS_HISTORY" 
        ADD CONSTRAINT "SUBJECTS_HISTORY_MODIFIED_BY_FK" 
        FOREIGN KEY ("MODIFIED_BY") 
        REFERENCES "USERS"("ID") 
        ON DELETE SET NULL;
    END IF;
END $$;

-- Add table comment for documentation
COMMENT ON TABLE "SUBJECTS_HISTORY" IS 
    'Audit trail for SUBJECTS table - captures snapshot of data before UPDATE or DELETE operations';

COMMENT ON COLUMN "SUBJECTS_HISTORY"."HISTORY_ID" IS 
    'Unique identifier for each history record';

COMMENT ON COLUMN "SUBJECTS_HISTORY"."OPERATION_TYPE" IS 
    'Type of operation that triggered the history record (UPDATE or DELETE)';

COMMENT ON COLUMN "SUBJECTS_HISTORY"."MODIFIED_AT" IS 
    'Timestamp when the modification occurred';

COMMENT ON COLUMN "SUBJECTS_HISTORY"."MODIFIED_BY" IS 
    'ID of the user who performed the modification (nullable for system operations)';

-- ============================================================================
-- Step 2: Create Trigger Function
-- ============================================================================

-- Drop function if exists (for idempotency and updates)
DROP FUNCTION IF EXISTS log_subjects_changes() CASCADE;

-- Create the trigger function
CREATE OR REPLACE FUNCTION log_subjects_changes()
RETURNS TRIGGER AS $$
DECLARE
    v_modified_by BIGINT;
    v_operation_type VARCHAR(10);
BEGIN
    -- Determine operation type
    IF (TG_OP = 'DELETE') THEN
        v_operation_type := 'DELETE';
    ELSIF (TG_OP = 'UPDATE') THEN
        v_operation_type := 'UPDATE';
    END IF;
    
    -- Try to get the current user ID from session variable
    -- This can be set by the application: SET LOCAL app.current_user_id = 123;
    BEGIN
        v_modified_by := current_setting('app.current_user_id', true)::BIGINT;
    EXCEPTION
        WHEN OTHERS THEN
            v_modified_by := NULL;
    END;
    
    -- Insert the OLD row data into history table
    INSERT INTO "SUBJECTS_HISTORY" (
        "OPERATION_TYPE",
        "MODIFIED_AT",
        "MODIFIED_BY",
        "ID",
        "TYPE_STRUCTURE",
        "CODE_UKNF",
        "NAME_STRUCTURE",
        "LEI",
        "NIP",
        "KRS",
        "STREET",
        "NR_STRET",
        "NR_HOUSE",
        "POST_CODE",
        "TOWN",
        "PHONE",
        "EMAIL",
        "UKNF_ID",
        "STATUS_S",
        "KATEGORY_S",
        "SELEKTOR_S",
        "SUBSELEKTOR_S",
        "TRANS_S",
        "DATE_CREATE",
        "DATE_ACTRUALIZATION",
        "VALIDATED"
    ) VALUES (
        v_operation_type,
        NOW(),
        v_modified_by,
        OLD."ID",
        OLD."TYPE_STRUCTURE",
        OLD."CODE_UKNF",
        OLD."NAME_STRUCTURE",
        OLD."LEI",
        OLD."NIP",
        OLD."KRS",
        OLD."STREET",
        OLD."NR_STRET",
        OLD."NR_HOUSE",
        OLD."POST_CODE",
        OLD."TOWN",
        OLD."PHONE",
        OLD."EMAIL",
        OLD."UKNF_ID",
        OLD."STATUS_S",
        OLD."KATEGORY_S",
        OLD."SELEKTOR_S",
        OLD."SUBSELEKTOR_S",
        OLD."TRANS_S",
        OLD."DATE_CREATE",
        OLD."DATE_ACTRUALIZATION",
        OLD."VALIDATED"
    );
    
    -- Return appropriate value based on operation
    IF (TG_OP = 'DELETE') THEN
        RETURN OLD;
    ELSE
        RETURN NEW;
    END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Add function comment
COMMENT ON FUNCTION log_subjects_changes() IS 
    'Trigger function that logs changes to SUBJECTS table into SUBJECTS_HISTORY';

-- ============================================================================
-- Step 3: Create Trigger
-- ============================================================================

-- Drop trigger if exists (for idempotency)
DROP TRIGGER IF EXISTS subjects_history_trigger ON "SUBJECTS";

-- Create the trigger
CREATE TRIGGER subjects_history_trigger
    AFTER UPDATE OR DELETE ON "SUBJECTS"
    FOR EACH ROW
    EXECUTE FUNCTION log_subjects_changes();

-- ============================================================================
-- Verification Queries (for debugging - commented out)
-- ============================================================================

-- Uncomment these to verify the installation:

-- -- Check if table exists
-- SELECT table_name, table_type
-- FROM information_schema.tables
-- WHERE table_schema = 'public'
--   AND table_name = 'SUBJECTS_HISTORY';

-- -- Check if function exists
-- SELECT routine_name, routine_type
-- FROM information_schema.routines
-- WHERE routine_schema = 'public'
--   AND routine_name = 'log_subjects_changes';

-- -- Check if trigger exists
-- SELECT trigger_name, event_manipulation, event_object_table
-- FROM information_schema.triggers
-- WHERE trigger_schema = 'public'
--   AND trigger_name = 'subjects_history_trigger';

-- -- Check indexes
-- SELECT indexname, tablename
-- FROM pg_indexes
-- WHERE tablename = 'SUBJECTS_HISTORY';

-- ============================================================================
-- Usage Examples
-- ============================================================================

-- Example 1: Set user ID before making changes (application should do this)
-- BEGIN;
--     SET LOCAL app.current_user_id = 5;
--     UPDATE "SUBJECTS" SET "NAME_STRUCTURE" = 'New Name' WHERE "ID" = 1;
-- COMMIT;

-- Example 2: Query history for a specific subject
-- SELECT 
--     "HISTORY_ID",
--     "OPERATION_TYPE",
--     "MODIFIED_AT",
--     "MODIFIED_BY",
--     "NAME_STRUCTURE",
--     "STATUS_S"
-- FROM "SUBJECTS_HISTORY"
-- WHERE "ID" = 1
-- ORDER BY "MODIFIED_AT" DESC;

-- Example 3: Get all changes made by a specific user
-- SELECT 
--     sh."HISTORY_ID",
--     sh."OPERATION_TYPE",
--     sh."MODIFIED_AT",
--     sh."ID" as subject_id,
--     sh."NAME_STRUCTURE",
--     u."USER_NAME",
--     u."USER_LASTNAME"
-- FROM "SUBJECTS_HISTORY" sh
-- LEFT JOIN "USERS" u ON sh."MODIFIED_BY" = u."ID"
-- WHERE sh."MODIFIED_BY" = 5
-- ORDER BY sh."MODIFIED_AT" DESC;

-- Example 4: Compare current state with previous state
-- WITH subject_current AS (
--     SELECT * FROM "SUBJECTS" WHERE "ID" = 1
-- ),
-- subject_previous AS (
--     SELECT * FROM "SUBJECTS_HISTORY" 
--     WHERE "ID" = 1 
--     ORDER BY "MODIFIED_AT" DESC 
--     LIMIT 1
-- )
-- SELECT 
--     'Current' as state,
--     sc."NAME_STRUCTURE",
--     sc."STATUS_S",
--     sc."DATE_ACTRUALIZATION"
-- FROM subject_current sc
-- UNION ALL
-- SELECT 
--     'Previous' as state,
--     sp."NAME_STRUCTURE",
--     sp."STATUS_S",
--     sp."DATE_ACTRUALIZATION"
-- FROM subject_previous sp;

-- Example 5: Audit report - all changes in last 30 days
-- SELECT 
--     sh."MODIFIED_AT",
--     sh."OPERATION_TYPE",
--     sh."ID" as subject_id,
--     sh."NAME_STRUCTURE" as subject_name,
--     u."EMAIL" as modified_by_email,
--     u."USER_NAME" || ' ' || u."USER_LASTNAME" as modified_by_name
-- FROM "SUBJECTS_HISTORY" sh
-- LEFT JOIN "USERS" u ON sh."MODIFIED_BY" = u."ID"
-- WHERE sh."MODIFIED_AT" >= NOW() - INTERVAL '30 days'
-- ORDER BY sh."MODIFIED_AT" DESC;

COMMIT;

-- ============================================================================
-- Post-Installation Notes
-- ============================================================================

-- 1. Application Integration:
--    Before any UPDATE or DELETE on SUBJECTS, your application should set:
--    SET LOCAL app.current_user_id = <user_id>;
--    This will be automatically captured in the MODIFIED_BY column.

-- 2. Performance Considerations:
--    - The trigger adds minimal overhead (one INSERT per UPDATE/DELETE)
--    - Indexes are optimized for common query patterns
--    - Consider partitioning SUBJECTS_HISTORY by MODIFIED_AT for very large datasets

-- 3. Data Retention:
--    - History records are never automatically deleted
--    - Implement a retention policy if needed (e.g., archive after 7 years)
--    - Example cleanup query:
--      DELETE FROM "SUBJECTS_HISTORY" WHERE "MODIFIED_AT" < NOW() - INTERVAL '7 years';

-- 4. Monitoring:
--    - Monitor the size of SUBJECTS_HISTORY table
--    - Set up alerts for unusual modification patterns
--    - Regular audit reviews recommended

-- 5. GDPR/Compliance:
--    - History table contains full snapshots including personal data
--    - Ensure proper access controls
--    - Consider encryption at rest
--    - Document retention policies

